<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPC Playground - Amstrad CPC Development Environment</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --accent-color: #0f3460;
            --highlight-color: #e94560;
            --text-color: #eaeaea;
            --text-muted: #888;
            --border-radius: 6px;
            --success-color: #4caf50;
            --error-color: #f44336;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--panel-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--highlight-color);
        }

        .logo span {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            background: var(--accent-color);
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn:hover {
            background: var(--highlight-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--highlight-color);
        }

        .btn-primary:hover {
            background: #ff6b6b;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #66bb6a;
        }

        /* Main layout */
        main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Resizable panels */
        .panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-editor {
            flex: 1;
            min-width: 300px;
            border-right: 2px solid var(--accent-color);
        }

        .panel-emulator {
            width: 400px;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: var(--panel-color);
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            border-bottom: 1px solid var(--accent-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Monaco Editor container */
        #editor-container {
            flex: 1;
            overflow: hidden;
        }

        /* Emulator canvas */
        .emulator-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
        }

        /* Console output */
        .console-panel {
            height: 150px;
            background: #0d1117;
            border-top: 1px solid var(--accent-color);
            display: flex;
            flex-direction: column;
        }

        #console {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .console-line {
            margin: 0.1rem 0;
        }

        .console-info {
            color: #58a6ff;
        }

        .console-success {
            color: var(--success-color);
        }

        .console-error {
            color: var(--error-color);
        }

        .console-warning {
            color: #ffa500;
        }

        /* Status bar */
        .status-bar {
            background: var(--panel-color);
            padding: 0.3rem 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--accent-color);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.ready {
            background: var(--success-color);
        }

        .status-dot.running {
            background: #2196f3;
            animation: pulse 1s infinite;
        }

        .status-dot.error {
            background: var(--error-color);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Resizer */
        .resizer {
            width: 4px;
            background: var(--accent-color);
            cursor: col-resize;
            transition: background 0.2s;
        }

        .resizer:hover {
            background: var(--highlight-color);
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--accent-color);
            border-top-color: var(--highlight-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 1rem;
            color: var(--text-muted);
        }

        /* Examples dropdown */
        .dropdown {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--panel-color);
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .dropdown-item:hover {
            background: var(--accent-color);
        }
    </style>
</head>

<body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Loading CPC Playground...</div>
    </div>

    <header>
        <div class="logo">
            <h1>CPC Playground</h1>
            <span>Z80 Assembly for Amstrad CPC</span>
        </div>
        <div class="toolbar">
            <div class="dropdown">
                <button class="btn">üìÅ Examples ‚ñæ</button>
                <div class="dropdown-content">
                    <div class="dropdown-item" data-example="hello">Hello World</div>
                    <div class="dropdown-item" data-example="colors">Color Bars</div>
                    <div class="dropdown-item" data-example="scroll">Scroll Text</div>
                    <div class="dropdown-item" data-example="sprite">Simple Sprite</div>
                </div>
            </div>
            <select class="btn" id="output-format" style="padding: 0.4rem 0.5rem;">
                <option value="sna">üì¶ SNA (Snapshot)</option>
                <option value="dsk">üíæ DSK (Disk)</option>
            </select>
            <button class="btn btn-success" id="btn-run" disabled>‚ñ∂ Build &amp; Run</button>
            <button class="btn" id="btn-reset">üîÑ Reset</button>
            <button class="btn" id="btn-download">‚¨á Download</button>
        </div>
    </header>

    <main>
        <!-- Editor Panel -->
        <div class="panel panel-editor">
            <div class="panel-header">
                <span>üìù source.asm</span>
                <span id="editor-status">Ready</span>
            </div>
            <div id="editor-container"></div>
        </div>

        <!-- Resizer -->
        <div class="resizer" id="resizer"></div>

        <!-- Emulator Panel -->
        <div class="panel panel-emulator">
            <div class="panel-header">
                <span>üñ•Ô∏è Emulator</span>
                <span id="emu-status">Loading...</span>
            </div>
            <div class="emulator-wrapper">
                <canvas id="canvas" width="768" height="544" tabindex="1"></canvas>
            </div>
            <div class="console-panel">
                <div class="panel-header">
                    <span>üìã Console</span>
                    <button class="btn" style="padding: 0.2rem 0.5rem; font-size: 0.75rem;"
                        id="btn-clear">Clear</button>
                </div>
                <div id="console"></div>
            </div>
        </div>
    </main>

    <div class="status-bar">
        <div class="status-item">
            <span class="status-dot" id="status-rasm"></span>
            <span>RASM</span>
        </div>
        <div class="status-item">
            <span class="status-dot" id="status-emu"></span>
            <span>CPCEC</span>
        </div>
        <div style="flex: 1;"></div>
        <div class="status-item" id="binary-size"></div>
    </div>

    <!-- Monaco Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

    <script>
        // ===== Global state =====
        let editor = null;
        let RASM = null;
        let compiledBinary = null;
        let compiledFormat = 'sna'; // 'sna' or 'dsk'

        // ===== Console logging =====
        const consoleEl = document.getElementById('console');

        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line console-${type}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // ===== Example programs =====
        const examples = {
            hello: `; Hello World - CPC Playground
; Displays "HELLO CPC!" on screen

    org #4000       ; Start address

start:
    ld hl, message  ; Point to message
    call print_str  ; Print it
    ret

print_str:
    ld a, (hl)      ; Get character
    or a            ; Is it zero?
    ret z           ; Yes, done
    call #bb5a      ; CPC firmware: TXT OUTPUT
    inc hl          ; Next character
    jr print_str    ; Loop

message:
    db "HELLO CPC!", 0
`,
            colors: `; Color Bars - CPC Playground
; Displays colored bars using firmware

    org #4000

start:
    call #bc02      ; SCR SET MODE (mode 0)
    ld a, 0
    
    ld b, 16        ; 16 colors
    ld c, 0         ; Start color
    
loop:
    push bc
    ld a, c
    call #bc32      ; GRA SET PEN
    
    ; Draw a line
    ld de, 0        ; X start
    ld hl, 0        ; Y start  
    call #bbc0      ; MOVE to start
    
    ld de, 639      ; X end
    ld hl, 0
    call #bbf6      ; DRAW line
    
    pop bc
    inc c           ; Next color
    djnz loop
    
    ret
`,
            scroll: `; Scroll Text - CPC Playground
; Simple scrolling message

    org #4000

start:
    ld hl, message
    
scroll_loop:
    push hl
    call print_line
    pop hl
    
    ; Small delay
    ld bc, #1000
delay:
    dec bc
    ld a, b
    or c
    jr nz, delay
    
    inc hl
    ld a, (hl)
    or a
    jr nz, scroll_loop
    
    ret

print_line:
    ld b, 40        ; 40 chars per line
pl_loop:
    ld a, (hl)
    or a
    jr z, pl_space
    call #bb5a      ; TXT OUTPUT
    inc hl
    djnz pl_loop
    ret
pl_space:
    ld a, ' '
    call #bb5a
    djnz pl_loop
    ret

message:
    db "    *** CPC PLAYGROUND - Z80 ASSEMBLY DEMO ***    ", 0
`,
            sprite: `; Simple Sprite - CPC Playground
; Draws a simple 8x8 sprite

    org #4000

start:
    call #bc02      ; SCR SET MODE (mode 1)
    
    ; Set position
    ld de, 160      ; X position
    ld hl, 100      ; Y position
    call #bbc0      ; MOVE
    
    ; Draw sprite
    ld hl, sprite_data
    ld b, 8         ; 8 lines
    
draw_line:
    push bc
    push hl
    
    ld a, (hl)      ; Get line data
    ld b, 8         ; 8 pixels
    
draw_pixel:
    push bc
    push af
    
    rlca            ; Get top bit
    jr nc, skip_pixel
    
    ld a, 1
    call #bc32      ; GRA SET PEN
    call #bbea      ; PLOT
    
skip_pixel:
    ; Move right
    ld de, 4
    ld hl, 0
    call #bbc9      ; MOVE RELATIVE
    
    pop af
    pop bc
    djnz draw_pixel
    
    ; Move to next line
    ld de, -32      ; Back to start
    ld hl, -2       ; Down one line
    call #bbc9
    
    pop hl
    inc hl
    pop bc
    djnz draw_line
    
    ret

sprite_data:
    db %00111100
    db %01111110
    db %11111111
    db %11111111
    db %11111111
    db %11111111
    db %01111110
    db %00111100
`
        };

        // ===== Initialize Monaco Editor =====
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Register Z80 Assembly language
            monaco.languages.register({ id: 'z80asm' });

            monaco.languages.setMonarchTokensProvider('z80asm', {
                ignoreCase: true,
                tokenizer: {
                    root: [
                        // Comments
                        [/;.*$/, 'comment'],

                        // Labels
                        [/^[a-zA-Z_][a-zA-Z0-9_]*:/, 'type.identifier'],
                        [/^\.[a-zA-Z_][a-zA-Z0-9_]*/, 'type.identifier'],

                        // Directives
                        [/\b(org|db|dw|ds|equ|include|incbin|macro|endm|if|else|endif|repeat|endr)\b/i, 'keyword'],

                        // Z80 instructions
                        [/\b(ld|push|pop|ex|exx|ldi|ldir|ldd|lddr|cpl|neg|ccf|scf|nop|halt|di|ei|im|add|adc|sub|sbc|and|or|xor|cp|inc|dec|daa|rlca|rrca|rla|rra|rlc|rl|rrc|rr|sla|sra|srl|bit|set|res|jp|jr|djnz|call|ret|reti|retn|rst|in|out|ini|inir|ind|indr|outi|otir|outd|otdr)\b/i, 'keyword.control'],

                        // Registers
                        [/\b(a|b|c|d|e|h|l|af|bc|de|hl|sp|ix|iy|ixh|ixl|iyh|iyl|i|r|af')\b/i, 'variable'],

                        // Conditions
                        [/\b(nz|z|nc|c|po|pe|p|m)\b/i, 'variable.predefined'],

                        // Numbers
                        [/#[0-9a-fA-F]+/, 'number.hex'],
                        [/\$[0-9a-fA-F]+/, 'number.hex'],
                        [/&[0-9a-fA-F]+/, 'number.hex'],
                        [/0x[0-9a-fA-F]+/, 'number.hex'],
                        [/%[01]+/, 'number.binary'],
                        [/\b[0-9]+\b/, 'number'],

                        // Strings
                        [/"[^"]*"/, 'string'],
                        [/'[^']*'/, 'string'],
                    ]
                }
            });

            // Create editor
            editor = monaco.editor.create(document.getElementById('editor-container'), {
                value: examples.hello,
                language: 'z80asm',
                theme: 'vs-dark',
                fontSize: 14,
                minimap: { enabled: false },
                automaticLayout: true,
                scrollBeyondLastLine: false,
                lineNumbers: 'on',
                renderLineHighlight: 'all',
                tabSize: 4,
                insertSpaces: true
            });

            log('Monaco Editor initialized', 'success');
            document.getElementById('editor-status').textContent = 'Ready';
        });

        // ===== Load RASM =====
        async function loadRASM() {
            try {
                log('Loading RASM assembler...');
                const script = document.createElement('script');
                script.src = 'rasm.js';
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                // Create the RASM module instance (reused for all compilations)
                RASM = await createRASM();
                log('RASM loaded successfully', 'success');
                document.getElementById('status-rasm').classList.add('ready');
                return true;
            } catch (e) {
                log('Failed to load RASM: ' + e.message, 'error');
                document.getElementById('status-rasm').classList.add('error');
                return false;
            }
        }

        // ===== Extract ORG address from source =====
        function extractOrgAddress(source) {
            // Match org directive with various formats: org #1234, org $1234, org &1234, org 0x1234, org 4096
            const match = source.match(/^\s*org\s+(?:#|\$|&|0x)?([0-9a-fA-F]+)/im);
            if (match) {
                return parseInt(match[1], 16);
            }
            return 0x4000; // Default org address
        }

        // ===== Wrap source code for SNA generation =====
        function wrapForSNA(source) {
            const orgAddress = extractOrgAddress(source);
            const orgHex = orgAddress.toString(16).toUpperCase();

            // Wrap with RASM directives for SNA generation
            const wrapped = `; === Auto-generated SNA wrapper ===
BUILDSNA
BANKSET 0

${source}

; === Set execution address ===
run #${orgHex}
`;

            return { wrapped, orgAddress, format: 'sna' };
        }

        // ===== Wrap source code for DSK generation =====
        function wrapForDSK(source) {
            const orgAddress = extractOrgAddress(source);
            const orgHex = orgAddress.toString(16).toUpperCase();

            // Wrap with RASM directives for DSK generation
            // SAVE 'filename', start, size, DSK, 'diskname.dsk'
            // start = org address, size = $ - start (current position - start)
            const wrapped = `; === Auto-generated DSK wrapper ===

${source}

; === Save binary to disk ===
; start = #${orgHex}, size = $ - #${orgHex}
save 'program.bin', #${orgHex}, $ - #${orgHex}, DSK, 'output.dsk'
`;

            return { wrapped, orgAddress, format: 'dsk' };
        }

        // ===== Get current output format =====
        function getOutputFormat() {
            return document.getElementById('output-format').value;
        }

        // ===== Compile =====
        async function compile() {
            if (!RASM || !editor) return null;

            const source = editor.getValue();
            const format = getOutputFormat();

            try {
                // Wrap source code based on format
                const wrapper = format === 'dsk' ? wrapForDSK(source) : wrapForSNA(source);
                const { wrapped, orgAddress } = wrapper;
                log(`ORG address detected: #${orgAddress.toString(16).toUpperCase()}`);
                log(`Output format: ${format.toUpperCase()}`);

                // Write wrapped source to virtual FS
                RASM.FS.writeFile('/source.asm', wrapped);

                // Debug: show wrapped source
                console.log('=== Wrapped source ===');
                console.log(wrapped);
                console.log('======================');

                log(`Compiling to ${format.toUpperCase()}...`);

                // Capture stdout/stderr
                let output = '';
                const originalPrint = RASM.print;
                const originalPrintErr = RASM.printErr;
                RASM.print = (text) => { output += text + '\n'; console.log('RASM:', text); };
                RASM.printErr = (text) => { output += text + '\n'; console.log('RASM ERR:', text); log(text, 'error'); };

                // Run RASM with format-specific arguments
                let exitCode = 0;
                let rasmArgs;

                if (format === 'dsk') {
                    // DSK output
                    rasmArgs = ['/source.asm', '-ob', '/output.bin', '-s'];
                } else {
                    // SNA output (default)
                    rasmArgs = ['/source.asm', '-ob', '/output.bin', '-s', '-oi', '/output.sna'];
                }

                try {
                    // Verify the source file exists and show its content
                    const sourceContent = RASM.FS.readFile('/source.asm', { encoding: 'utf8' });
                    log(`Source file size: ${sourceContent.length} chars`);

                    exitCode = RASM.callMain(rasmArgs);
                    log(`RASM exit code: ${exitCode}`, exitCode === 0 ? 'success' : 'error');
                } catch (e) {
                    // RASM may call exit() which throws - check if it's a normal exit
                    if (e.name === 'ExitStatus') {
                        exitCode = e.status;
                        log(`RASM exited with code: ${exitCode}`, 'info');
                    } else {
                        log(`RASM threw: ${e}`, 'warning');
                    }
                }

                RASM.print = originalPrint;
                RASM.printErr = originalPrintErr;

                // Log RASM output
                if (output.trim()) {
                    log('RASM output: ' + output.trim(), 'info');
                } else {
                    log('RASM produced no output', 'warning');
                }

                // List files in virtual FS to see what was created
                try {
                    const files = RASM.FS.readdir('/');
                    log('Files in FS: ' + files.filter(f => f !== '.' && f !== '..').join(', '), 'info');
                } catch (e) { }

                // Read output based on format
                let result = null;

                if (format === 'dsk') {
                    // For DSK, RASM creates the DSK file with the name specified in SAVE directive
                    try {
                        const dsk = RASM.FS.readFile('/output.dsk');
                        compiledBinary = dsk;
                        compiledFormat = 'dsk';
                        log(`Compilation successful! DSK size: ${dsk.length} bytes`, 'success');
                        document.getElementById('binary-size').textContent = `DSK: ${dsk.length} bytes`;
                        result = dsk;
                    } catch (e) {
                        log('Compilation failed - no DSK generated. Error: ' + e.message, 'error');
                        if (output) log(output, 'warning');
                    }
                } else {
                    // SNA output
                    try {
                        const sna = RASM.FS.readFile('/output.sna');
                        compiledBinary = sna;
                        compiledFormat = 'sna';
                        log(`Compilation successful! SNA size: ${sna.length} bytes`, 'success');
                        document.getElementById('binary-size').textContent = `SNA: ${sna.length} bytes`;
                        result = sna;
                    } catch (e) {
                        log('Compilation failed - no SNA generated. Error: ' + e.message, 'error');
                        if (output) log(output, 'warning');
                    }
                }

                // Cleanup
                try { RASM.FS.unlink('/source.asm'); } catch (e) { }
                try { RASM.FS.unlink('/output.bin'); } catch (e) { }
                try { RASM.FS.unlink('/output.sna'); } catch (e) { }
                try { RASM.FS.unlink('/output.dsk'); } catch (e) { }

                return result;
            } catch (e) {
                log('Compilation error: ' + e.message, 'error');
                return null;
            }
        }

        // ===== Load binary into emulator =====
        async function loadBinaryIntoEmulator(binary) {
            if (!Module || !Module._em_load_file) {
                log('Emulator not ready', 'error');
                return false;
            }

            try {
                // Write file to emulator's virtual FS with appropriate extension
                const filename = `/program.${compiledFormat}`;
                Module.FS.writeFile(filename, binary);

                // Load it - CPCEC will recognize the format by extension
                Module._em_load_file(Module.allocateUTF8(filename));

                log(`${compiledFormat.toUpperCase()} loaded into emulator - program running!`, 'success');
                return true;
            } catch (e) {
                log(`Failed to load ${compiledFormat.toUpperCase()} into emulator: ` + e.message, 'error');
                return false;
            }
        }

        // ===== Build & Run =====
        async function buildAndRun() {
            document.getElementById('btn-run').disabled = true;

            const binary = await compile();
            if (binary) {
                await loadBinaryIntoEmulator(binary);
            }

            document.getElementById('btn-run').disabled = false;
        }

        // ===== Download compiled binary =====
        function downloadBinary() {
            if (!compiledBinary) {
                log('No compiled binary available', 'warning');
                return;
            }

            const blob = new Blob([compiledBinary], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `program.${compiledFormat}`;
            a.click();
            URL.revokeObjectURL(url);
            log(`${compiledFormat.toUpperCase()} downloaded`, 'info');
        }

        // ===== Event handlers =====
        document.getElementById('btn-run').addEventListener('click', buildAndRun);
        document.getElementById('btn-reset').addEventListener('click', () => {
            if (Module && Module._em_reset) {
                Module._em_reset();
                log('Emulator reset', 'info');
            }
        });
        document.getElementById('btn-download').addEventListener('click', downloadBinary);
        document.getElementById('btn-clear').addEventListener('click', () => {
            consoleEl.innerHTML = '';
        });

        // Example buttons
        document.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('click', () => {
                const example = item.dataset.example;
                if (examples[example] && editor) {
                    editor.setValue(examples[example]);
                    log(`Loaded example: ${item.textContent}`, 'info');
                }
            });
        });

        // Resizer
        const resizer = document.getElementById('resizer');
        const editorPanel = document.querySelector('.panel-editor');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = e.clientX;
            if (newWidth > 200 && newWidth < window.innerWidth - 300) {
                editorPanel.style.flex = 'none';
                editorPanel.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = '';
        });

        // Keyboard shortcut: Ctrl+Enter to build & run
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                buildAndRun();
            }
            // Map Option/Alt key to CPC COPY (0x09) when canvas is focused
            const canvas = document.getElementById('canvas');
            if (document.activeElement === canvas) {
                if (e.code === 'AltLeft' || e.code === 'AltRight') {
                    e.preventDefault();
                    if (Module._em_key_press) {
                        Module._em_key_press(0x09); // CPC COPY
                    }
                }
                // Map Shift+0-9 to CPC function keys F0-F9
                if (e.shiftKey && e.code && e.code.startsWith('Digit')) {
                    e.preventDefault();
                    e.stopPropagation();
                    var fnNum = parseInt(e.code.charAt(5));
                    if (Module._em_press_fn) {
                        Module._em_press_fn(fnNum);
                    }
                }
            }
        });

        // Handle Option/Alt and Shift+number key releases for CPC keys
        document.addEventListener('keyup', (e) => {
            const canvas = document.getElementById('canvas');
            if (document.activeElement === canvas) {
                // Release CPC COPY when Option/Alt is released
                if (e.code === 'AltLeft' || e.code === 'AltRight') {
                    if (Module._em_key_release) {
                        Module._em_key_release(0x09); // CPC COPY
                    }
                }
                // Release CPC function keys
                if (e.code && e.code.startsWith('Digit')) {
                    var fnNum = parseInt(e.code.charAt(5));
                    if (Module._em_release_fn) {
                        Module._em_release_fn(fnNum);
                    }
                }
            }
        });

        // ===== Emulator Module configuration =====
        var Module = {
            canvas: document.getElementById('canvas'),

            setStatus: function (text) {
                document.getElementById('emu-status').textContent = text || 'Ready';
                if (text === '') {
                    document.getElementById('status-emu').classList.add('ready');
                }
            },

            onRuntimeInitialized: function () {
                log('CPCEC emulator initialized', 'success');
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('btn-run').disabled = false;
            },

            print: function (text) {
                console.log(text);
            },

            printErr: function (text) {
                console.error(text);
            }
        };

        // ===== Initialize =====
        async function init() {
            log('Initializing CPC Playground...');
            await loadRASM();
        }

        init();
    </script>

    <!-- Load CPCEC emulator -->
    <script async src="cpcec.js"></script>
</body>

</html>