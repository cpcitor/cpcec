<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CPC Playground - Amstrad CPC Development Environment</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --accent-color: #0f3460;
            --highlight-color: #e94560;
            --text-color: #eaeaea;
            --text-muted: #888;
            --border-radius: 6px;
            --success-color: #4caf50;
            --error-color: #f44336;
        }

        html,
        body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            background: var(--panel-color);
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--accent-color);
            flex-shrink: 0;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--highlight-color);
        }

        .logo span {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            background: var(--accent-color);
            color: var(--text-color);
            border: none;
            padding: 0.5rem 1rem;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }

        .btn:hover {
            background: var(--highlight-color);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--highlight-color);
        }

        .btn-primary:hover {
            background: #ff6b6b;
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #66bb6a;
        }

        /* Main layout */
        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panels-row {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* Resizable panels */
        .panel {
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-editor {
            flex: 1;
            min-width: 300px;
            border-right: 2px solid var(--accent-color);
        }

        .panel-emulator {
            width: 400px;
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: var(--panel-color);
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-muted);
            border-bottom: 1px solid var(--accent-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Monaco Editor container */
        #editor-container {
            flex: 1;
            overflow: hidden;
        }

        /* Emulator canvas */
        .emulator-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            overflow: hidden;
        }

        #canvas {
            display: block;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            max-width: 100%;
            max-height: 100%;
        }

        /* Console output - full width at bottom */
        .console-panel {
            height: 150px;
            background: #0d1117;
            border-top: 2px solid var(--accent-color);
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        #console {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8rem;
            line-height: 1.4;
        }

        .console-line {
            margin: 0.1rem 0;
            white-space: pre-wrap;
        }

        .console-info {
            color: #58a6ff;
        }

        .console-success {
            color: var(--success-color);
        }

        .console-error {
            color: var(--error-color);
        }

        .console-warning {
            color: #ffa500;
        }

        /* Status bar */
        .status-bar {
            background: var(--panel-color);
            padding: 0.3rem 1rem;
            font-size: 0.75rem;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
            border-top: 1px solid var(--accent-color);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-dot.ready {
            background: var(--success-color);
        }

        .status-dot.running {
            background: #2196f3;
            animation: pulse 1s infinite;
        }

        .status-dot.error {
            background: var(--error-color);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Resizer */
        .resizer {
            width: 4px;
            background: var(--accent-color);
            cursor: col-resize;
            transition: background 0.2s;
        }

        .resizer:hover {
            background: var(--highlight-color);
        }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid var(--accent-color);
            border-top-color: var(--highlight-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            margin-top: 1rem;
            color: var(--text-muted);
        }

        /* Examples dropdown */
        .dropdown {
            position: relative;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--panel-color);
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            min-width: 200px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .dropdown:hover .dropdown-content {
            display: block;
        }

        .dropdown-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .dropdown-item:hover {
            background: var(--accent-color);
        }

        .dropdown-divider {
            height: 1px;
            background: var(--accent-color);
            margin: 0.3rem 0;
        }

        .dropdown-item .shortcut {
            float: right;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        /* Hidden file input */
        #file-input {
            display: none;
        }

        /* Save dialog */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--panel-color);
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            min-width: 350px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }

        .modal h3 {
            margin-bottom: 1rem;
            color: var(--highlight-color);
        }

        .modal input[type="text"] {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
            background: var(--bg-color);
            color: var(--text-color);
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }

        .modal input[type="text"]:focus {
            outline: none;
            border-color: var(--highlight-color);
        }

        .modal-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        .saved-programs-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 1rem;
            border: 1px solid var(--accent-color);
            border-radius: var(--border-radius);
        }

        .saved-program-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .saved-program-item:hover {
            background: var(--accent-color);
        }

        .saved-program-item.selected {
            background: var(--highlight-color);
        }

        .saved-program-item .delete-btn {
            color: var(--error-color);
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            opacity: 0.7;
        }

        .saved-program-item .delete-btn:hover {
            opacity: 1;
        }

        .empty-list {
            padding: 1rem;
            text-align: center;
            color: var(--text-muted);
        }
    </style>
</head>

<body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loading">
        <div class="spinner"></div>
        <div class="loading-text">Loading CPC Playground...</div>
    </div>

    <!-- Hidden file input for import -->
    <input type="file" id="file-input" accept=".asm,.z80,.s">

    <!-- Save Modal -->
    <div class="modal-overlay" id="save-modal">
        <div class="modal">
            <h3>üíæ Save Program</h3>
            <input type="text" id="save-name" placeholder="Program name...">
            <div class="modal-buttons">
                <button class="btn" id="save-cancel">Cancel</button>
                <button class="btn btn-primary" id="save-confirm">Save</button>
            </div>
        </div>
    </div>

    <!-- Load Modal -->
    <div class="modal-overlay" id="load-modal">
        <div class="modal">
            <h3>üìÇ Load Program</h3>
            <div class="saved-programs-list" id="saved-programs-list">
                <div class="empty-list">No saved programs</div>
            </div>
            <div class="modal-buttons">
                <button class="btn" id="load-cancel">Cancel</button>
                <button class="btn btn-primary" id="load-confirm" disabled>Load</button>
            </div>
        </div>
    </div>

    <header>
        <div class="logo">
            <h1>CPC Playground</h1>
            <span>Z80 Assembly for Amstrad CPC</span>
        </div>
        <div class="toolbar">
            <!-- Files menu -->
            <div class="dropdown">
                <button class="btn">üìÑ File ‚ñæ</button>
                <div class="dropdown-content">
                    <div class="dropdown-item" id="file-new">New <span class="shortcut">‚åòN</span></div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" id="file-save">Save... <span class="shortcut">‚åòS</span></div>
                    <div class="dropdown-item" id="file-load">Load...</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" id="file-import">Import .asm</div>
                    <div class="dropdown-item" id="file-export">Export .asm</div>
                </div>
            </div>
            <!-- Examples menu -->
            <div class="dropdown">
                <button class="btn">üìÅ Examples ‚ñæ</button>
                <div class="dropdown-content">
                    <div class="dropdown-item" data-example="hello">Hello World</div>
                    <div class="dropdown-item" data-example="colors">Color Bars</div>
                    <div class="dropdown-item" data-example="scroll">Scroll Text</div>
                    <div class="dropdown-item" data-example="sprite">Simple Sprite</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" data-example="keyboard">Keyboard Input</div>
                    <div class="dropdown-item" data-example="sound">Sound Effects</div>
                    <div class="dropdown-item" data-example="lines">Draw Lines</div>
                </div>
            </div>
            <select class="btn" id="output-format" style="padding: 0.4rem 0.5rem;">
                <option value="sna">üì¶ SNA (Snapshot)</option>
                <option value="dsk">üíæ DSK (Disk)</option>
            </select>
            <button class="btn btn-success" id="btn-run" disabled>‚ñ∂ Build &amp; Run</button>
            <button class="btn" id="btn-reset">üîÑ Reset</button>
            <button class="btn" id="btn-download">‚¨á Download</button>
        </div>
    </header>

    <div class="main-container">
        <div class="panels-row">
            <!-- Editor Panel -->
            <div class="panel panel-editor">
                <div class="panel-header">
                    <span>üìù source.asm</span>
                    <span id="editor-status">Ready</span>
                </div>
                <div id="editor-container"></div>
            </div>

            <!-- Resizer -->
            <div class="resizer" id="resizer"></div>

            <!-- Emulator Panel -->
            <div class="panel panel-emulator">
                <div class="panel-header">
                    <span>üñ•Ô∏è Emulator</span>
                    <span id="emu-status">Loading...</span>
                </div>
                <div class="emulator-wrapper">
                    <canvas id="canvas" width="768" height="544" tabindex="-1"></canvas>
                </div>
            </div>
        </div>

        <!-- Console Panel - full width -->
        <div class="console-panel">
            <div class="panel-header">
                <span>üìã Console</span>
                <button class="btn" style="padding: 0.2rem 0.5rem; font-size: 0.75rem;" id="btn-clear">Clear</button>
            </div>
            <div id="console"></div>
        </div>
    </div>

    <div class="status-bar">
        <div class="status-item">
            <span class="status-dot" id="status-rasm"></span>
            <span>RASM</span>
        </div>
        <div class="status-item">
            <span class="status-dot" id="status-emu"></span>
            <span>CPCEC</span>
        </div>
        <div style="flex: 1;"></div>
        <div class="status-item" id="binary-size"></div>
    </div>

    <!-- Monaco Editor -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs/loader.min.js"></script>

    <script>
        // ===== Global state =====
        let editor = null;
        let compiledBinary = null;
        let compiledFormat = 'sna'; // 'sna' or 'dsk'

        // ===== Console logging =====
        const consoleEl = document.getElementById('console');

        // ANSI color code to CSS color mapping
        const ansiColors = {
            '30': '#000',      // Black
            '31': '#e74c3c',   // Red
            '32': '#2ecc71',   // Green
            '33': '#f1c40f',   // Yellow
            '34': '#3498db',   // Blue
            '35': '#9b59b6',   // Magenta
            '36': '#1abc9c',   // Cyan
            '37': '#ecf0f1',   // White
            '90': '#7f8c8d',   // Bright Black (Gray)
            '91': '#ff6b6b',   // Bright Red
            '92': '#4caf50',   // Bright Green
            '93': '#ffeb3b',   // Bright Yellow
            '94': '#64b5f6',   // Bright Blue
            '95': '#ce93d8',   // Bright Magenta
            '96': '#4dd0e1',   // Bright Cyan
            '97': '#fff'       // Bright White
        };

        // Convert ANSI codes to HTML spans
        function ansiToHtml(text) {
            // Replace ANSI escape sequences with HTML
            // Pattern: ESC[<code>m or just [<code>m
            return text.replace(/\x1b?\[([0-9;]+)m/g, (match, codes) => {
                const codeList = codes.split(';');
                for (const code of codeList) {
                    if (code === '0') {
                        return '</span>';
                    }
                    if (ansiColors[code]) {
                        return `<span style="color: ${ansiColors[code]}">`;
                    }
                }
                return '';
            }).replace(/</g, (m, offset, str) => {
                // Don't escape our span tags
                if (str.substr(offset, 5) === '<span' || str.substr(offset, 7) === '</span>') {
                    return '<';
                }
                return '&lt;';
            });
        }

        // Simpler ANSI parser that handles the [0m[32m pattern
        // Only matches ANSI codes: [digits;digits...m (must be only digits/semicolons before m)
        function parseAnsi(text) {
            let result = '';
            let i = 0;
            let inSpan = false;

            while (i < text.length) {
                // Check for ESC[ or just [ followed by only digits/semicolons then m
                let isAnsi = false;
                let escLen = 0;
                
                if (text[i] === '\x1b' && text[i + 1] === '[') {
                    escLen = 2;
                    isAnsi = true;
                } else if (text[i] === '[') {
                    // Check if this looks like an ANSI code: [digits;...m
                    let j = i + 1;
                    while (j < text.length && (/[0-9;]/.test(text[j]))) {
                        j++;
                    }
                    // Must have at least one digit and end with 'm'
                    if (j > i + 1 && text[j] === 'm') {
                        escLen = 1;
                        isAnsi = true;
                    }
                }
                
                if (isAnsi) {
                    i += escLen; // skip ESC[ or [

                    // Read the code until 'm'
                    let code = '';
                    while (i < text.length && text[i] !== 'm') {
                        code += text[i];
                        i++;
                    }
                    i++; // skip 'm'

                    // Close previous span
                    if (inSpan) {
                        result += '</span>';
                        inSpan = false;
                    }

                    // Open new span if it's a color code
                    if (code !== '0' && ansiColors[code]) {
                        result += `<span style="color: ${ansiColors[code]}">`;
                        inSpan = true;
                    }
                } else {
                    // Escape HTML special chars
                    if (text[i] === '<') result += '&lt;';
                    else if (text[i] === '>') result += '&gt;';
                    else if (text[i] === '&') result += '&amp;';
                    else result += text[i];
                    i++;
                }
            }

            if (inSpan) result += '</span>';
            return result;
        }

        function log(message, type = 'info') {
            const line = document.createElement('div');
            line.className = `console-line console-${type}`;
            const timestamp = `[${new Date().toLocaleTimeString()}] `;

            // Check if message contains ANSI codes (look for [ followed by digits and m)
            if (/\[\d+m/.test(message)) {
                line.innerHTML = timestamp + parseAnsi(message);
            } else {
                line.textContent = timestamp + message;
            }

            consoleEl.appendChild(line);
            consoleEl.scrollTop = consoleEl.scrollHeight;
        }

        // ===== Example programs =====
        const examples = {
            hello: `; Hello World - CPC Playground
; Displays "HELLO CPC!" on screen

    org #4000       ; Start address

start:
    ld hl, message  ; Point to message
    call print_str  ; Print it
    ret

print_str:
    ld a, (hl)      ; Get character
    or a            ; Is it zero?
    ret z           ; Yes, done
    call #bb5a      ; CPC firmware: TXT OUTPUT
    inc hl          ; Next character
    jr print_str    ; Loop

message:
    db "HELLO CPC!", 0
`,
            colors: `; Color Bars - CPC Playground
; Displays colored bars using firmware

    org #4000

start:
    call #bc02      ; SCR SET MODE (mode 0)
    ld a, 0
    
    ld b, 16        ; 16 colors
    ld c, 0         ; Start color
    
loop:
    push bc
    ld a, c
    call #bc32      ; GRA SET PEN
    
    ; Draw a line
    ld de, 0        ; X start
    ld hl, 0        ; Y start  
    call #bbc0      ; MOVE to start
    
    ld de, 639      ; X end
    ld hl, 0
    call #bbf6      ; DRAW line
    
    pop bc
    inc c           ; Next color
    djnz loop
    
    ret
`,
            scroll: `; Scroll Text - CPC Playground
; Simple scrolling message

    org #4000

start:
    ld hl, message
    
scroll_loop:
    push hl
    call print_line
    pop hl
    
    ; Small delay
    ld bc, #1000
delay:
    dec bc
    ld a, b
    or c
    jr nz, delay
    
    inc hl
    ld a, (hl)
    or a
    jr nz, scroll_loop
    
    ret

print_line:
    ld b, 40        ; 40 chars per line
pl_loop:
    ld a, (hl)
    or a
    jr z, pl_space
    call #bb5a      ; TXT OUTPUT
    inc hl
    djnz pl_loop
    ret
pl_space:
    ld a, ' '
    call #bb5a
    djnz pl_loop
    ret

message:
    db "    *** CPC PLAYGROUND - Z80 ASSEMBLY DEMO ***    ", 0
`,
            sprite: `; Simple Sprite - CPC Playground
; Draws a simple 8x8 sprite

    org #4000

start:
    call #bc02      ; SCR SET MODE (mode 1)
    
    ; Set position
    ld de, 160      ; X position
    ld hl, 100      ; Y position
    call #bbc0      ; MOVE
    
    ; Draw sprite
    ld hl, sprite_data
    ld b, 8         ; 8 lines
    
draw_line:
    push bc
    push hl
    
    ld a, (hl)      ; Get line data
    ld b, 8         ; 8 pixels
    
draw_pixel:
    push bc
    push af
    
    rlca            ; Get top bit
    jr nc, skip_pixel
    
    ld a, 1
    call #bc32      ; GRA SET PEN
    call #bbea      ; PLOT
    
skip_pixel:
    ; Move right
    ld de, 4
    ld hl, 0
    call #bbc9      ; MOVE RELATIVE
    
    pop af
    pop bc
    djnz draw_pixel
    
    ; Move to next line
    ld de, -32      ; Back to start
    ld hl, -2       ; Down one line
    call #bbc9
    
    pop hl
    inc hl
    pop bc
    djnz draw_line
    
    ret

sprite_data:
    db %00111100
    db %01111110
    db %11111111
    db %11111111
    db %11111111
    db %11111111
    db %01111110
    db %00111100
`,
            keyboard: `; Keyboard Input - CPC Playground
; Move a character with cursor keys

    org #4000

start:
    ld a, 1
    call #bc0e      ; MODE 1
    
    ; Initial position (center of screen)
    ld bc, 20       ; Column
    ld de, 12       ; Row
    
main_loop:
    push bc
    push de
    
    ; Position cursor
    call #bb75      ; TXT SET CURSOR
    
    ; Draw character
    ld a, '*'
    call #bb5a      ; TXT OUTPUT
    
    ; Wait for key
    call #bb18      ; KM WAIT KEY
    
    ; Erase character
    pop de
    pop bc
    push bc
    push de
    call #bb75
    ld a, ' '
    call #bb5a
    pop de
    pop bc
    
    ; Check direction
    cp 240          ; Up
    jr nz, not_up
    dec d
    jr main_loop
not_up:
    cp 241          ; Down
    jr nz, not_down
    inc d
    jr main_loop
not_down:
    cp 242          ; Left
    jr nz, not_left
    dec c
    jr main_loop
not_left:
    cp 243          ; Right
    jr nz, not_right
    inc c
not_right:
    jr main_loop
`,
            sound: `; Sound Effects - CPC Playground
; Play simple sounds using firmware

    org #4000

start:
    ; Play a sequence of notes
    ld hl, notes
    ld b, 8         ; Number of notes
    
play_loop:
    push bc
    push hl
    
    ; Get note period
    ld c, (hl)
    inc hl
    ld b, (hl)
    inc hl
    
    ; Play note
    ld a, 1         ; Channel A
    ld d, 0         ; Volume envelope
    ld e, 15        ; Volume (max)
    ld h, 0
    ld l, 20        ; Duration
    call #bcaa      ; SOUND QUEUE
    
    ; Wait for sound
wait:
    ld a, 1
    call #bca7      ; SOUND CHECK
    or a
    jr nz, wait
    
    pop hl
    inc hl
    inc hl
    pop bc
    djnz play_loop
    
    ret

notes:
    ; Period values for notes (lower = higher pitch)
    dw 478          ; C
    dw 426          ; D
    dw 379          ; E
    dw 358          ; F
    dw 319          ; G
    dw 284          ; A
    dw 253          ; B
    dw 239          ; C (octave up)
`,
            lines: `; Draw Lines - CPC Playground
; Draw colorful lines pattern

    org #4000

start:
    ; Set mode 0 (160x200, 16 colors)
    ld a, 0
    call #bc0e      ; SCR SET MODE
    
    ld b, 32        ; Number of lines
    ld de, 0        ; X start
    
draw_loop:
    push bc
    push de
    
    ; Set pen color
    ld a, b
    and 15
    call #bc32      ; GRA SET PEN
    
    ; Move to start
    pop de
    push de
    ld hl, 0
    call #bbc0      ; GRA MOVE ABSOLUTE
    
    ; Draw to opposite corner
    pop de
    push de
    ld a, 159
    sub e
    ld e, a
    ld d, 0
    ld hl, 399
    call #bbf6      ; GRA LINE ABSOLUTE
    
    pop de
    ld a, e
    add a, 5
    ld e, a
    
    pop bc
    djnz draw_loop
    
    ret
`
        };

        // ===== Initialize Monaco Editor =====
        require.config({ paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.45.0/min/vs' } });

        require(['vs/editor/editor.main'], function () {
            // Register Z80 Assembly language
            monaco.languages.register({ id: 'z80asm' });

            monaco.languages.setMonarchTokensProvider('z80asm', {
                ignoreCase: true,
                tokenizer: {
                    root: [
                        // Comments
                        [/;.*$/, 'comment'],

                        // Labels
                        [/^[a-zA-Z_][a-zA-Z0-9_]*:/, 'type.identifier'],
                        [/^\.[a-zA-Z_][a-zA-Z0-9_]*/, 'type.identifier'],

                        // Directives
                        [/\b(org|db|dw|ds|equ|include|incbin|macro|endm|if|else|endif|repeat|endr)\b/i, 'keyword'],

                        // Z80 instructions
                        [/\b(ld|push|pop|ex|exx|ldi|ldir|ldd|lddr|cpl|neg|ccf|scf|nop|halt|di|ei|im|add|adc|sub|sbc|and|or|xor|cp|inc|dec|daa|rlca|rrca|rla|rra|rlc|rl|rrc|rr|sla|sra|srl|bit|set|res|jp|jr|djnz|call|ret|reti|retn|rst|in|out|ini|inir|ind|indr|outi|otir|outd|otdr)\b/i, 'keyword.control'],

                        // Registers
                        [/\b(a|b|c|d|e|h|l|af|bc|de|hl|sp|ix|iy|ixh|ixl|iyh|iyl|i|r|af')\b/i, 'variable'],

                        // Conditions
                        [/\b(nz|z|nc|c|po|pe|p|m)\b/i, 'variable.predefined'],

                        // Numbers
                        [/#[0-9a-fA-F]+/, 'number.hex'],
                        [/\$[0-9a-fA-F]+/, 'number.hex'],
                        [/&[0-9a-fA-F]+/, 'number.hex'],
                        [/0x[0-9a-fA-F]+/, 'number.hex'],
                        [/%[01]+/, 'number.binary'],
                        [/\b[0-9]+\b/, 'number'],

                        // Strings
                        [/"[^"]*"/, 'string'],
                        [/'[^']*'/, 'string'],
                    ]
                }
            });

            // Create editor
            editor = monaco.editor.create(document.getElementById('editor-container'), {
                value: examples.hello,
                language: 'z80asm',
                theme: 'vs-dark',
                fontSize: 14,
                minimap: { enabled: false },
                automaticLayout: true,
                scrollBeyondLastLine: false,
                lineNumbers: 'on',
                renderLineHighlight: 'all',
                tabSize: 4,
                insertSpaces: true
            });

            // Ensure editor gets focus when clicked
            document.getElementById('editor-container').addEventListener('click', () => {
                editor.focus();
            });

            // Stop keyboard events from propagating to CPCEC when editor is focused
            // This prevents the emulator from capturing keys while typing in the editor
            document.getElementById('editor-container').addEventListener('keydown', (e) => {
                e.stopPropagation();
            }, true);
            document.getElementById('editor-container').addEventListener('keyup', (e) => {
                e.stopPropagation();
            }, true);
            document.getElementById('editor-container').addEventListener('keypress', (e) => {
                e.stopPropagation();
            }, true);

            log('Monaco Editor initialized', 'success');
            document.getElementById('editor-status').textContent = 'Ready';
        });

        // ===== RASM output capture =====
        let rasmStdout = [];
        let rasmStderr = [];
        let rasmLoaded = false;

        function clearRasmOutput() {
            rasmStdout = [];
            rasmStderr = [];
        }

        // ===== Load RASM script =====
        async function loadRASM() {
            try {
                log('Loading RASM assembler...');
                const script = document.createElement('script');
                script.src = 'rasm.js';
                document.head.appendChild(script);

                await new Promise((resolve, reject) => {
                    script.onload = resolve;
                    script.onerror = reject;
                });

                rasmLoaded = true;
                log('RASM loaded successfully', 'success');
                document.getElementById('status-rasm').classList.add('ready');
                return true;
            } catch (e) {
                log('Failed to load RASM: ' + e.message, 'error');
                document.getElementById('status-rasm').classList.add('error');
                return false;
            }
        }

        // Create a fresh RASM instance for each compilation
        async function createRasmInstance() {
            clearRasmOutput();
            return await createRASM({
                print: (text) => {
                    rasmStdout.push(text);
                    console.log('RASM:', text);
                },
                printErr: (text) => {
                    rasmStderr.push(text);
                    console.error('RASM ERR:', text);
                }
            });
        }

        // ===== Extract ORG address from source =====
        function extractOrgAddress(source) {
            // Match org directive with various formats: org #1234, org $1234, org &1234, org 0x1234, org 4096
            const match = source.match(/^\s*org\s+(?:#|\$|&|0x)?([0-9a-fA-F]+)/im);
            if (match) {
                return parseInt(match[1], 16);
            }
            return 0x4000; // Default org address
        }

        // ===== Wrap source code for SNA generation =====
        function wrapForSNA(source) {
            const orgAddress = extractOrgAddress(source);
            const orgHex = orgAddress.toString(16).toUpperCase();

            // Wrap with RASM directives for SNA generation
            const wrapped = `; === Auto-generated SNA wrapper ===
BUILDSNA
BANKSET 0

${source}

; === Set execution address ===
run #${orgHex}
`;

            return { wrapped, orgAddress, format: 'sna' };
        }

        // ===== Wrap source code for DSK generation =====
        function wrapForDSK(source) {
            const orgAddress = extractOrgAddress(source);
            const orgHex = orgAddress.toString(16).toUpperCase();

            // Wrap with RASM directives for DSK generation
            // Use labels to calculate size properly
            const wrapped = `; === Auto-generated DSK wrapper ===

__DSK_START__ equ #${orgHex}

${source}

__DSK_END__:
; === Save binary to disk ===
save "program.bin",__DSK_START__,__DSK_END__-__DSK_START__,DSK,"output.dsk"
`;

            return { wrapped, orgAddress, format: 'dsk' };
        }

        // ===== Get current output format =====
        function getOutputFormat() {
            return document.getElementById('output-format').value;
        }

        // ===== Compile =====
        async function compile() {
            if (!rasmLoaded || !editor) return null;

            const source = editor.getValue();
            const format = getOutputFormat();

            try {
                // Create fresh RASM instance for this compilation
                log('Creating RASM instance...');
                const rasm = await createRasmInstance();
                
                // Wrap source code based on format
                const wrapper = format === 'dsk' ? wrapForDSK(source) : wrapForSNA(source);
                const { wrapped, orgAddress } = wrapper;
                log(`ORG address detected: #${orgAddress.toString(16).toUpperCase()}`);
                log(`Output format: ${format.toUpperCase()}`);

                // Write wrapped source to virtual FS
                rasm.FS.writeFile('/source.asm', wrapped);

                // Debug: show wrapped source
                console.log('=== Wrapped source ===');
                console.log(wrapped);
                console.log('======================');

                log(`Compiling to ${format.toUpperCase()}...`);

                // Run RASM with format-specific arguments
                let exitCode = 0;
                let rasmArgs;

                if (format === 'dsk') {
                    // DSK output
                    rasmArgs = ['/source.asm', '-ob', '/output.bin', '-s'];
                } else {
                    // SNA output (default)
                    rasmArgs = ['/source.asm', '-ob', '/output.bin', '-s', '-oi', '/output.sna'];
                }

                try {
                    // Verify the source file exists and show its content
                    const sourceContent = rasm.FS.readFile('/source.asm', { encoding: 'utf8' });
                    log(`Source file size: ${sourceContent.length} chars`);

                    exitCode = rasm.callMain(rasmArgs);
                    log(`RASM exit code: ${exitCode}`, exitCode === 0 ? 'success' : 'error');
                } catch (e) {
                    // RASM may call exit() which throws - check if it's a normal exit
                    if (e.name === 'ExitStatus') {
                        exitCode = e.status;
                        log(`RASM exited with code: ${exitCode}`, 'info');
                    } else {
                        log(`RASM threw: ${e}`, 'warning');
                    }
                }

                // Log RASM output
                if (rasmStdout.length > 0) {
                    rasmStdout.forEach(line => {
                        if (line.trim()) log(line, 'info');
                    });
                }
                if (rasmStderr.length > 0) {
                    rasmStderr.forEach(line => {
                        if (line.trim()) log(line, 'error');
                    });
                }

                // List files in virtual FS to see what was created
                try {
                    const files = rasm.FS.readdir('/');
                    log('Files in FS: ' + files.filter(f => f !== '.' && f !== '..').join(', '), 'info');
                } catch (e) { }

                // Read output based on format
                let result = null;

                if (format === 'dsk') {
                    // For DSK, RASM creates the DSK file with the name specified in SAVE directive
                    try {
                        const dsk = rasm.FS.readFile('/output.dsk');
                        compiledBinary = dsk;
                        compiledFormat = 'dsk';
                        log(`Compilation successful! DSK size: ${dsk.length} bytes`, 'success');
                        document.getElementById('binary-size').textContent = `DSK: ${dsk.length} bytes`;
                        result = dsk;
                    } catch (e) {
                        log('Compilation failed - no DSK generated', 'error');
                    }
                } else {
                    // SNA output
                    try {
                        const sna = rasm.FS.readFile('/output.sna');
                        compiledBinary = sna;
                        compiledFormat = 'sna';
                        log(`Compilation successful! SNA size: ${sna.length} bytes`, 'success');
                        document.getElementById('binary-size').textContent = `SNA: ${sna.length} bytes`;
                        result = sna;
                    } catch (e) {
                        log('Compilation failed - no SNA generated', 'error');
                    }
                }

                // No cleanup needed - rasm instance is discarded after each compilation

                return result;
            } catch (e) {
                log('Compilation error: ' + e.message, 'error');
                return null;
            }
        }

        // ===== Load binary into emulator =====
        async function loadBinaryIntoEmulator(binary) {
            if (!Module || !Module._em_load_file) {
                log('Emulator not ready', 'error');
                return false;
            }

            try {
                // Write file to emulator's virtual FS with appropriate extension
                const filename = `/program.${compiledFormat}`;
                Module.FS.writeFile(filename, binary);

                // Load it - CPCEC will recognize the format by extension
                Module._em_load_file(Module.allocateUTF8(filename));

                log(`${compiledFormat.toUpperCase()} loaded into emulator - program running!`, 'success');
                return true;
            } catch (e) {
                log(`Failed to load ${compiledFormat.toUpperCase()} into emulator: ` + e.message, 'error');
                return false;
            }
        }

        // ===== Build & Run =====
        async function buildAndRun() {
            document.getElementById('btn-run').disabled = true;

            const binary = await compile();
            if (binary) {
                await loadBinaryIntoEmulator(binary);
            }

            document.getElementById('btn-run').disabled = false;
        }

        // ===== Download compiled binary =====
        function downloadBinary() {
            if (!compiledBinary) {
                log('No compiled binary available', 'warning');
                return;
            }

            const blob = new Blob([compiledBinary], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `program.${compiledFormat}`;
            a.click();
            URL.revokeObjectURL(url);
            log(`${compiledFormat.toUpperCase()} downloaded`, 'info');
        }

        // ===== File Management =====
        const STORAGE_KEY = 'cpc-playground-programs';
        let currentProgramName = '';
        let selectedProgramToLoad = '';

        function getSavedPrograms() {
            const data = localStorage.getItem(STORAGE_KEY);
            return data ? JSON.parse(data) : {};
        }

        function saveProgram(name, code) {
            const programs = getSavedPrograms();
            programs[name] = {
                code: code,
                savedAt: new Date().toISOString()
            };
            localStorage.setItem(STORAGE_KEY, JSON.stringify(programs));
        }

        function deleteProgram(name) {
            const programs = getSavedPrograms();
            delete programs[name];
            localStorage.setItem(STORAGE_KEY, JSON.stringify(programs));
        }

        function loadProgram(name) {
            const programs = getSavedPrograms();
            if (programs[name]) {
                return programs[name].code;
            }
            return null;
        }

        // New file
        function newFile() {
            if (editor) {
                editor.setValue('; New CPC Program\\n; Write your Z80 assembly code here\\n\\n    org #4000\\n\\nstart:\\n    ret\\n');
                currentProgramName = '';
                log('New file created', 'info');
            }
        }

        // Show save modal
        function showSaveModal() {
            document.getElementById('save-modal').classList.add('active');
            const input = document.getElementById('save-name');
            input.value = currentProgramName || '';
            input.focus();
            input.select();
        }

        function hideSaveModal() {
            document.getElementById('save-modal').classList.remove('active');
        }

        function confirmSave() {
            const name = document.getElementById('save-name').value.trim();
            if (!name) {
                log('Please enter a program name', 'warning');
                return;
            }
            if (editor) {
                saveProgram(name, editor.getValue());
                currentProgramName = name;
                log(`Program "${name}" saved`, 'success');
                hideSaveModal();
            }
        }

        // Show load modal
        function showLoadModal() {
            selectedProgramToLoad = '';
            document.getElementById('load-confirm').disabled = true;
            updateSavedProgramsList();
            document.getElementById('load-modal').classList.add('active');
        }

        function hideLoadModal() {
            document.getElementById('load-modal').classList.remove('active');
        }

        function updateSavedProgramsList() {
            const list = document.getElementById('saved-programs-list');
            const programs = getSavedPrograms();
            const names = Object.keys(programs).sort();

            if (names.length === 0) {
                list.innerHTML = '<div class="empty-list">No saved programs</div>';
                return;
            }

            list.innerHTML = names.map(name => {
                const date = new Date(programs[name].savedAt).toLocaleDateString();
                return `
                    <div class="saved-program-item" data-name="${name}">
                        <span>${name} <small style="color: var(--text-muted)">(${date})</small></span>
                        <span class="delete-btn" data-delete="${name}">üóë</span>
                    </div>
                `;
            }).join('');

            // Add click handlers
            list.querySelectorAll('.saved-program-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (e.target.classList.contains('delete-btn')) return;
                    list.querySelectorAll('.saved-program-item').forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedProgramToLoad = item.dataset.name;
                    document.getElementById('load-confirm').disabled = false;
                });

                item.addEventListener('dblclick', (e) => {
                    if (e.target.classList.contains('delete-btn')) return;
                    confirmLoad();
                });
            });

            // Delete buttons
            list.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const name = btn.dataset.delete;
                    if (confirm(`Delete "${name}"?`)) {
                        deleteProgram(name);
                        log(`Program "${name}" deleted`, 'info');
                        updateSavedProgramsList();
                    }
                });
            });
        }

        function confirmLoad() {
            if (!selectedProgramToLoad) return;
            const code = loadProgram(selectedProgramToLoad);
            if (code && editor) {
                editor.setValue(code);
                currentProgramName = selectedProgramToLoad;
                log(`Program "${selectedProgramToLoad}" loaded`, 'success');
                hideLoadModal();
            }
        }

        // Import .asm file
        function importFile() {
            document.getElementById('file-input').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                if (editor) {
                    editor.setValue(e.target.result);
                    currentProgramName = file.name.replace(/\\.(asm|z80|s)$/i, '');
                    log(`Imported: ${file.name}`, 'success');
                }
            };
            reader.readAsText(file);
            event.target.value = ''; // Reset input
        }

        // Export .asm file
        function exportFile() {
            if (!editor) return;
            const code = editor.getValue();
            const filename = (currentProgramName || 'program') + '.asm';

            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            log(`Exported: ${filename}`, 'info');
        }

        // ===== Event handlers =====
        document.getElementById('btn-run').addEventListener('click', buildAndRun);
        document.getElementById('btn-reset').addEventListener('click', () => {
            if (Module && Module._em_reset) {
                Module._em_reset();
                log('Emulator reset', 'info');
            }
        });
        document.getElementById('btn-download').addEventListener('click', downloadBinary);
        document.getElementById('btn-clear').addEventListener('click', () => {
            consoleEl.innerHTML = '';
        });

        // File menu handlers
        document.getElementById('file-new').addEventListener('click', newFile);
        document.getElementById('file-save').addEventListener('click', showSaveModal);
        document.getElementById('file-load').addEventListener('click', showLoadModal);
        document.getElementById('file-import').addEventListener('click', importFile);
        document.getElementById('file-export').addEventListener('click', exportFile);
        document.getElementById('file-input').addEventListener('change', handleFileImport);

        // Save modal handlers
        document.getElementById('save-cancel').addEventListener('click', hideSaveModal);
        document.getElementById('save-confirm').addEventListener('click', confirmSave);
        
        // Stop propagation on save input to prevent CPCEC from capturing keys
        const saveInput = document.getElementById('save-name');
        saveInput.addEventListener('keydown', (e) => {
            e.stopPropagation();
            if (e.key === 'Enter') confirmSave();
            if (e.key === 'Escape') hideSaveModal();
        });
        saveInput.addEventListener('keyup', (e) => e.stopPropagation());
        saveInput.addEventListener('keypress', (e) => e.stopPropagation());

        // Load modal handlers
        document.getElementById('load-cancel').addEventListener('click', hideLoadModal);
        document.getElementById('load-confirm').addEventListener('click', confirmLoad);

        // Close modals when clicking overlay
        document.getElementById('save-modal').addEventListener('click', (e) => {
            if (e.target.id === 'save-modal') hideSaveModal();
        });
        document.getElementById('load-modal').addEventListener('click', (e) => {
            if (e.target.id === 'load-modal') hideLoadModal();
        });

        // Example buttons
        document.querySelectorAll('.dropdown-item[data-example]').forEach(item => {
            item.addEventListener('click', () => {
                const example = item.dataset.example;
                if (examples[example] && editor) {
                    editor.setValue(examples[example]);
                    currentProgramName = '';
                    log(`Loaded example: ${item.textContent.trim()}`, 'info');
                }
            });
        });

        // Resizer
        const resizer = document.getElementById('resizer');
        const editorPanel = document.querySelector('.panel-editor');
        let isResizing = false;

        resizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
        });

        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;
            const newWidth = e.clientX;
            if (newWidth > 200 && newWidth < window.innerWidth - 300) {
                editorPanel.style.flex = 'none';
                editorPanel.style.width = newWidth + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isResizing = false;
            document.body.style.cursor = '';
        });

        // Intercept Tab key globally - if editor has focus, insert spaces
        document.addEventListener('keydown', (e) => {
            // Don't intercept if we're in a modal (input fields)
            if (document.querySelector('.modal-overlay.active')) {
                return;
            }
            if (e.key === 'Tab' && editor && editor.hasTextFocus()) {
                e.preventDefault();
                e.stopPropagation();
                if (e.shiftKey) {
                    editor.trigger('keyboard', 'outdent', null);
                } else {
                    editor.trigger('keyboard', 'tab', null);
                }
                return false;
            }
        }, true); // Capture phase

        // Keyboard shortcut: Ctrl+Enter to build & run, Cmd+S to save, Cmd+N for new
        document.addEventListener('keydown', (e) => {
            // Don't intercept shortcuts if we're typing in a modal input
            const activeEl = document.activeElement;
            const isInModal = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA');
            
            // Cmd/Ctrl + Enter = Build & Run (but not in modal)
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !isInModal) {
                e.preventDefault();
                buildAndRun();
            }
            // Cmd/Ctrl + S = Save (always works)
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();
                if (document.querySelector('.modal-overlay.active')) {
                    confirmSave();
                } else {
                    showSaveModal();
                }
            }
            // Cmd/Ctrl + N = New (only if not in modal)
            if ((e.ctrlKey || e.metaKey) && e.key === 'n' && !document.querySelector('.modal-overlay.active')) {
                e.preventDefault();
                newFile();
            }
            // Escape = close modals
            if (e.key === 'Escape') {
                hideSaveModal();
                hideLoadModal();
            }
            // Map Option/Alt key to CPC COPY (0x09) when canvas is focused
            const canvas = document.getElementById('canvas');
            if (document.activeElement === canvas) {
                if (e.code === 'AltLeft' || e.code === 'AltRight') {
                    e.preventDefault();
                    if (Module._em_key_press) {
                        Module._em_key_press(0x09); // CPC COPY
                    }
                }
                // Map Shift+0-9 to CPC function keys F0-F9
                if (e.shiftKey && e.code && e.code.startsWith('Digit')) {
                    e.preventDefault();
                    e.stopPropagation();
                    var fnNum = parseInt(e.code.charAt(5));
                    if (Module._em_press_fn) {
                        Module._em_press_fn(fnNum);
                    }
                }
            }
        });

        // Handle Option/Alt and Shift+number key releases for CPC keys
        document.addEventListener('keyup', (e) => {
            const canvas = document.getElementById('canvas');
            if (document.activeElement === canvas) {
                // Release CPC COPY when Option/Alt is released
                if (e.code === 'AltLeft' || e.code === 'AltRight') {
                    if (Module._em_key_release) {
                        Module._em_key_release(0x09); // CPC COPY
                    }
                }
                // Release CPC function keys
                if (e.code && e.code.startsWith('Digit')) {
                    var fnNum = parseInt(e.code.charAt(5));
                    if (Module._em_release_fn) {
                        Module._em_release_fn(fnNum);
                    }
                }
            }
        });

        // ===== Emulator Module configuration =====
        var Module = {
            canvas: document.getElementById('canvas'),

            setStatus: function (text) {
                document.getElementById('emu-status').textContent = text || 'Ready';
                if (text === '') {
                    document.getElementById('status-emu').classList.add('ready');
                }
            },

            onRuntimeInitialized: function () {
                log('CPCEC emulator initialized', 'success');
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('btn-run').disabled = false;
            },

            print: function (text) {
                console.log(text);
            },

            printErr: function (text) {
                console.error(text);
            }
        };

        // ===== Initialize =====
        async function init() {
            log('Initializing CPC Playground...');
            await loadRASM();
        }

        init();
    </script>

    <!-- Load CPCEC emulator -->
    <script async src="cpcec.js"></script>
</body>

</html>